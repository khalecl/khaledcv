<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to DOCX Converter</title>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #eef2f8 100%);
            min-height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            color: white;
            padding: 50px 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            will-change: background-position;
        }

        @keyframes gradientShift {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 50%, rgba(255, 255, 255, 0.15) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 1;
        }

        .header h1 {
            margin: 0 0 10px 0;
            font-size: 40px;
            font-weight: 700;
            position: relative;
            z-index: 2;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            letter-spacing: 1px;
        }

        .header p {
            margin: 0;
            font-size: 18px;
            opacity: 0.95;
            position: relative;
            z-index: 2;
            text-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);
        }

        .progress-container {
            width: 100%;
            height: 4px;
            background-color: #e0e0e0;
            position: relative;
            display: none;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-container.active {
            display: block;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
            flex: 1;
        }

        .panel {
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04), 0 4px 8px rgba(0, 0, 0, 0.06);
            overflow: hidden;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid #e8eef7;
            background-color: #fafbfc;
        }

        .panel-header h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }

        .panel-header .info {
            font-size: 12px;
            color: #999;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .upload-btn {
            padding: 6px 12px;
            font-size: 12px;
            background-color: #f0f0f0;
            color: #333;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
        }

        .upload-btn:hover {
            background-color: #e0e0e0;
        }

        textarea {
            flex: 1;
            padding: 20px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            border: none;
            outline: none;
            resize: none;
            background-color: #fafbfc;
        }

        .preview {
            flex: 1;
            padding: 20px;
            overflow: auto;
            font-size: 15px;
            line-height: 1.7;
        }

        .preview h1 {
            font-size: 26px;
            margin: 20px 0 12px;
            font-weight: 700;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
            color: #1a1a1a;
        }

        .preview h2 {
            font-size: 20px;
            margin: 18px 0 10px;
            font-weight: 600;
            color: #333;
        }

        .preview h3 {
            font-size: 17px;
            margin: 14px 0 8px;
            font-weight: 600;
            color: #555;
        }

        .preview h4, .preview h5, .preview h6 {
            margin: 12px 0 6px;
            font-weight: 600;
            color: #666;
        }

        .preview code {
            background-color: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
            color: #c7254e;
        }

        .preview pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 16px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 12px 0;
            font-size: 12px;
            line-height: 1.4;
        }

        .preview pre code {
            background: none;
            color: inherit;
            padding: 0;
        }

        .preview blockquote {
            border-left: 4px solid #667eea;
            padding-left: 16px;
            margin-left: 0;
            margin-top: 12px;
            margin-bottom: 12px;
            color: #666;
            font-style: italic;
        }

        .preview table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            border: 1px solid #ddd;
        }

        .preview th {
            background-color: #f5f5f5;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #ddd;
        }

        .preview td {
            padding: 10px 12px;
            border-bottom: 1px solid #eee;
        }

        .preview ul, .preview ol {
            margin-top: 8px;
            margin-bottom: 8px;
            padding-left: 24px;
        }

        .actions {
            display: flex;
            gap: 12px;
            padding: 20px;
            justify-content: center;
            background: white;
            border-top: 1px solid #e8eef7;
        }

        button {
            padding: 12px 32px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .convert-btn {
            background-color: #667eea;
            color: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .convert-btn:hover:not(:disabled) {
            background-color: #5568d3;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .convert-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .clear-btn {
            background-color: white;
            color: #333;
            border: 1px solid #ddd;
        }

        .clear-btn:hover {
            background-color: #f5f5f5;
        }

        .message {
            padding: 12px 20px;
            margin: 0 20px 20px;
            border-radius: 6px;
            text-align: center;
        }

        .error {
            background-color: #fee;
            color: #c00;
        }

        .success {
            background-color: #efe;
            color: #0c0;
        }

        .footer {
            background: linear-gradient(to bottom, #e8eef7, #dfe6f3);
            padding: 30px 20px;
            border-top: 1px solid #d0d8e8;
            text-align: center;
        }

        .footer p {
            margin: 0 0 8px;
            font-size: 14px;
            color: #555;
        }

        .footer .subtext {
            font-size: 12px;
            color: #999;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="progress-container" id="progressContainer">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <div class="container">
        <header class="header">
            <h1>üìù Markdown to DOCX Converter</h1>
            <p>Convert your markdown to Word documents with proper styles</p>
        </header>

        <div class="main-content">
            <div class="panel">
                <div class="panel-header">
                    <h2>Markdown Editor</h2>
                    <div class="file-input-wrapper">
                        <input type="file" id="mdFile" accept=".md,.markdown,.txt" />
                        <label for="mdFile" class="upload-btn">üìÇ Load .md File</label>
                    </div>
                </div>
                <textarea id="editor" placeholder="Paste or write your markdown here..." spellcheck="false"># Document Title

## Heading 1

### Heading 2

This is normal paragraph text with some **bold** and *italic* formatting.

#### Code Example

```python
def hello_world():
    print("Hello World!")
```

#### Lists

1. First numbered item
2. Second numbered item
3. Third numbered item

Bullet points:
- First bullet
- Second bullet
- Third bullet

#### Table Example

| Column 1 | Column 2 | Column 3 |
|----------|----------|----------|
| Data 1   | Data 2   | Data 3   |
| Data 4   | Data 5   | Data 6   |

#### Blockquote

> This is a quote from someone important.
> It can span multiple lines.

---

End of document.</textarea>
            </div>

            <div class="panel">
                <div class="panel-header">
                    <h2>Live Preview</h2>
                    <span class="info">How it will look in Word</span>
                </div>
                <div class="preview" id="preview"></div>
            </div>
        </div>

        <div id="message"></div>

        <div class="actions">
            <button class="convert-btn" id="convertBtn">‚¨áÔ∏è Download as DOCX</button>
            <button class="clear-btn" id="clearBtn">üóëÔ∏è Clear</button>
        </div>

        <footer class="footer">
            <p>üí° All markdown is converted to proper Word styles with harmonized typography</p>
            <p class="subtext">Built with Marked.js + JSZip | Professional Document Formatting</p>
        </footer>
    </div>

    <script>
        const editor = document.getElementById('editor');
        const preview = document.getElementById('preview');
        const convertBtn = document.getElementById('convertBtn');
        const clearBtn = document.getElementById('clearBtn');
        const messageEl = document.getElementById('message');
        const mdFile = document.getElementById('mdFile');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');

        function setProgress(percent) {
            progressBar.style.width = percent + '%';
        }

        function showProgress() {
            progressContainer.classList.add('active');
            setProgress(0);
        }

        function hideProgress() {
            progressContainer.classList.remove('active');
        }

        // Handle file upload
        mdFile.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const content = event.target.result;
                editor.value = content;
                preview.innerHTML = marked.parse(content);
                showMessage('‚úì File loaded successfully!', 'success');
                mdFile.value = '';
            };
            reader.onerror = () => {
                showMessage('Error reading file', 'error');
            };
            reader.readAsText(file);
        });

        // Update preview
        editor.addEventListener('input', () => {
            preview.innerHTML = marked.parse(editor.value);
        });

        // Initial preview
        preview.innerHTML = marked.parse(editor.value);

        // Clear
        clearBtn.addEventListener('click', () => {
            if (confirm('Clear all content?')) {
                editor.value = '';
                preview.innerHTML = '';
            }
        });

        function showMessage(text, type) {
            messageEl.className = 'message ' + type;
            messageEl.textContent = text;
            setTimeout(() => {
                messageEl.className = '';
                messageEl.textContent = '';
            }, 3000);
        }

        // Convert
        convertBtn.addEventListener('click', async () => {
            const markdown = editor.value.trim();
            if (!markdown) {
                showMessage('Please enter markdown content', 'error');
                return;
            }

            convertBtn.disabled = true;
            convertBtn.textContent = '‚è≥ Converting...';
            showProgress();

            try {
                setProgress(25);
                const docxBlob = await markdownToDocx(markdown);
                setProgress(75);
                saveAs(docxBlob, 'document.docx');
                setProgress(100);
                showMessage('‚úì Downloaded successfully!', 'success');
                setTimeout(hideProgress, 500);
            } catch (error) {
                console.error('Error:', error);
                showMessage('Error: ' + error.message, 'error');
                hideProgress();
            } finally {
                convertBtn.disabled = false;
                convertBtn.textContent = '‚¨áÔ∏è Download as DOCX';
            }
        });

        // Create valid DOCX with proper styles
        async function markdownToDocx(markdown) {
            const zip = new JSZip();

            // Required DOCX files
            zip.file('[Content_Types].xml', getContentTypes());
            zip.file('_rels/.rels', getRels());
            zip.file('word/_rels/document.xml.rels', getDocumentRels());
            zip.file('word/styles.xml', getStyles());
            zip.file('word/numbering.xml', getNumbering());
            zip.file('word/document.xml', getWordDocument(markdown));

            return await zip.generateAsync({ type: 'blob' });
        }

        function escapeXml(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        function parseTextFormatting(text) {
            let result = [];
            let i = 0;
            
            while (i < text.length) {
                // Bold (**text**)
                if (text.substring(i, i + 2) === '**') {
                    const endIdx = text.indexOf('**', i + 2);
                    if (endIdx !== -1) {
                        const boldText = text.substring(i + 2, endIdx);
                        result.push({ type: 'bold', text: boldText });
                        i = endIdx + 2;
                        continue;
                    }
                }
                // Italic (*text*) - but not ** which is bold
                if (text[i] === '*' && i + 1 < text.length && text[i + 1] !== '*') {
                    const endIdx = text.indexOf('*', i + 1);
                    if (endIdx !== -1 && text[endIdx + 1] !== '*') {
                        const italicText = text.substring(i + 1, endIdx);
                        result.push({ type: 'italic', text: italicText });
                        i = endIdx + 1;
                        continue;
                    }
                }
                // Italic (_text_)
                if (text[i] === '_' && i + 1 < text.length && text[i + 1] !== '_') {
                    const endIdx = text.indexOf('_', i + 1);
                    if (endIdx !== -1 && text[endIdx + 1] !== '_') {
                        const italicText = text.substring(i + 1, endIdx);
                        result.push({ type: 'italic', text: italicText });
                        i = endIdx + 1;
                        continue;
                    }
                }
                // Inline code (`text`)
                if (text[i] === '`') {
                    const endIdx = text.indexOf('`', i + 1);
                    if (endIdx !== -1) {
                        const codeText = text.substring(i + 1, endIdx);
                        result.push({ type: 'code', text: codeText });
                        i = endIdx + 1;
                        continue;
                    }
                }
                // Regular text (up to next formatting marker)
                let regularText = '';
                while (i < text.length && 
                       !(text[i] === '*' && (text[i + 1] === '*' || (i + 1 < text.length && text[i + 1] !== '*'))) &&
                       !(text[i] === '_' && (text[i + 1] === '_' || (i + 1 < text.length && text[i + 1] !== '_'))) &&
                       text[i] !== '`') {
                    regularText += text[i];
                    i++;
                }
                if (regularText) {
                    result.push({ type: 'text', text: regularText });
                }
            }
            return result;
        }

        function formatTextToXml(text) {
            const parts = parseTextFormatting(text);
            let xml = '';
            
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i];
                let textContent = part.text;
                
                // Add leading space if previous part was formatting and this is text
                if (i > 0 && part.type === 'text' && 
                    (parts[i-1].type === 'bold' || parts[i-1].type === 'italic' || parts[i-1].type === 'code') &&
                    !textContent.startsWith(' ')) {
                    // Space is preserved in the text
                }
                
                // Add trailing space preservation for formatted text
                if (part.type === 'bold') {
                    xml += '<w:r><w:rPr><w:b/></w:rPr><w:t xml:space="preserve">' + escapeXml(textContent) + '</w:t></w:r>';
                } else if (part.type === 'italic') {
                    xml += '<w:r><w:rPr><w:i/></w:rPr><w:t xml:space="preserve">' + escapeXml(textContent) + '</w:t></w:r>';
                } else if (part.type === 'code') {
                    xml += '<w:r><w:rPr><w:rFonts w:ascii="Courier New"/><w:color w:val="C7254E"/></w:rPr><w:t xml:space="preserve">' + escapeXml(textContent) + '</w:t></w:r>';
                } else {
                    xml += '<w:r><w:t xml:space="preserve">' + escapeXml(textContent) + '</w:t></w:r>';
                }
            }
            return xml;
        }

        function getContentTypes() {
            return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/><Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/><Override PartName="/word/numbering.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml"/></Types>';
        }

        function getRels() {
            return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/></Relationships>';
        }

        function getDocumentRels() {
            return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering" Target="numbering.xml"/></Relationships>';
        }

        function getNumbering() {
            return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><w:numbering xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"><w:abstractNum w:abstractNumId="0"><w:nsimple/><w:lvl w:ilvl="0"><w:start w:val="1"/><w:numFmt w:val="decimal"/><w:lvlText w:val="%1."/><w:lvlJc w:val="left"/><w:pPr><w:ind w:left="720" w:hanging="360"/></w:pPr></w:lvl></w:abstractNum><w:abstractNum w:abstractNumId="1"><w:nsimple/><w:lvl w:ilvl="0"><w:start w:val="1"/><w:numFmt w:val="bullet"/><w:lvlText w:val="‚Ä¢"/><w:lvlJc w:val="left"/><w:pPr><w:ind w:left="720" w:hanging="360"/></w:pPr></w:lvl></w:abstractNum><w:num w:numId="1"><w:abstractNumId w:val="0"/></w:num><w:num w:numId="2"><w:abstractNumId w:val="1"/></w:num></w:numbering>';
        }

        function getStyles() {
            return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"><w:docDefaults><w:rPrDefault><w:rPr><w:rFonts w:ascii="Calibri" w:hAnsi="Calibri"/><w:sz w:val="22"/></w:rPr></w:rPrDefault></w:docDefaults><w:style w:type="paragraph" w:styleId="Normal"><w:name w:val="Normal"/><w:qFormat/><w:pPr><w:spacing w:line="240" w:lineRule="auto"/></w:pPr></w:style><w:style w:type="paragraph" w:styleId="Title"><w:name w:val="Title"/><w:basedOn w:val="Normal"/><w:rPr><w:b/><w:sz w:val="40"/><w:color w:val="2F5496"/></w:rPr><w:pPr><w:spacing w:before="0" w:after="120" w:line="240" w:lineRule="auto"/><w:jc w:val="left"/></w:pPr></w:style><w:style w:type="paragraph" w:styleId="Heading1"><w:name w:val="Heading 1"/><w:basedOn w:val="Normal"/><w:rPr><w:b/><w:sz w:val="32"/><w:color w:val="2F5496"/></w:rPr><w:pPr><w:spacing w:before="120" w:after="80" w:line="240" w:lineRule="auto"/></w:pPr></w:style><w:style w:type="paragraph" w:styleId="Heading2"><w:name w:val="Heading 2"/><w:basedOn w:val="Normal"/><w:rPr><w:b/><w:sz w:val="28"/><w:color w:val="44546A"/></w:rPr><w:pPr><w:spacing w:before="100" w:after="60" w:line="240" w:lineRule="auto"/></w:pPr></w:style><w:style w:type="paragraph" w:styleId="Heading3"><w:name w:val="Heading 3"/><w:basedOn w:val="Normal"/><w:rPr><w:b/><w:sz w:val="26"/><w:color w:val="44546A"/></w:rPr><w:pPr><w:spacing w:before="80" w:after="40" w:line="240" w:lineRule="auto"/></w:pPr></w:style><w:style w:type="paragraph" w:styleId="Quote"><w:name w:val="Quote"/><w:basedOn w:val="Normal"/><w:rPr><w:i/><w:color w:val="404040"/></w:rPr><w:pPr><w:ind w:left="720"/><w:spacing w:before="60" w:after="60" w:line="240" w:lineRule="auto"/><w:pBdr><w:left w:val="single" w:sz="12" w:space="1" w:color="C0C0C0"/></w:pBdr></w:pPr></w:style><w:style w:type="paragraph" w:styleId="Code"><w:name w:val="Code"/><w:basedOn w:val="Normal"/><w:rPr><w:rFonts w:ascii="Courier New" w:hAnsi="Courier New"/><w:color w:val="C65911"/><w:sz w:val="20"/></w:rPr><w:pPr><w:spacing w:before="80" w:after="80" w:line="240" w:lineRule="auto"/><w:shd w:fill="F2F2F2"/><w:pBdr><w:top w:val="single" w:sz="6" w:space="1" w:color="E0E0E0"/><w:bottom w:val="single" w:sz="6" w:space="1" w:color="E0E0E0"/><w:left w:val="single" w:sz="6" w:space="1" w:color="E0E0E0"/><w:right w:val="single" w:sz="6" w:space="1" w:color="E0E0E0"/></w:pBdr></w:pPr></w:style><w:style w:type="paragraph" w:styleId="ListParagraph"><w:name w:val="List Paragraph"/><w:basedOn w:val="Normal"/><w:pPr><w:spacing w:line="240" w:lineRule="auto"/></w:pPr></w:style></w:styles>';
        }

        function buildTable(rows) {
            if (rows.length === 0) return '';

            let xml = '<w:tbl><w:tblPr>';
            xml += '<w:tblW w:w="5000" w:type="auto"/>';
            xml += '<w:tblInd w:w="0" w:type="dxa"/>';
            xml += '<w:tblBorders>';
            xml += '<w:top w:val="single" w:sz="12" w:space="0" w:color="4472C4"/>';
            xml += '<w:left w:val="single" w:sz="12" w:space="0" w:color="4472C4"/>';
            xml += '<w:bottom w:val="single" w:sz="12" w:space="0" w:color="4472C4"/>';
            xml += '<w:right w:val="single" w:sz="12" w:space="0" w:color="4472C4"/>';
            xml += '<w:insideH w:val="single" w:sz="12" w:space="0" w:color="D9E1F2"/>';
            xml += '<w:insideV w:val="single" w:sz="12" w:space="0" w:color="D9E1F2"/>';
            xml += '</w:tblBorders>';
            xml += '<w:tblCellMar>';
            xml += '<w:top w:w="100" w:type="dxa"/>';
            xml += '<w:left w:w="100" w:type="dxa"/>';
            xml += '<w:bottom w:w="100" w:type="dxa"/>';
            xml += '<w:right w:w="100" w:type="dxa"/>';
            xml += '</w:tblCellMar>';
            xml += '</w:tblPr>';

            rows.forEach((row, rowIdx) => {
                xml += '<w:tr>';
                xml += '<w:trPr>';
                xml += '<w:trHeight w:val="400" w:type="auto"/>';
                xml += '</w:trPr>';
                
                row.forEach(cell => {
                    const isHeader = rowIdx === 0;
                    const shading = isHeader ? '<w:shd w:fill="4472C4"/>' : '<w:shd w:fill="FFFFFF"/>';
                    const textColor = isHeader ? '<w:color w:val="FFFFFF"/>' : '';
                    
                    xml += '<w:tc>';
                    xml += '<w:tcPr>';
                    xml += '<w:tcW w:w="1000" w:type="auto"/>';
                    xml += shading;
                    xml += '<w:vAlign w:val="center"/>';
                    xml += '</w:tcPr>';
                    xml += '<w:p>';
                    xml += '<w:pPr>';
                    xml += '<w:jc w:val="center"/>';
                    xml += '<w:spacing w:line="240" w:lineRule="auto"/>';
                    xml += '</w:pPr>';
                    xml += '<w:r>';
                    xml += '<w:rPr>';
                    if (isHeader) {
                        xml += '<w:b/>';
                        xml += '<w:sz w:val="22"/>';
                    }
                    xml += textColor;
                    xml += '</w:rPr>';
                    xml += '<w:t xml:space="preserve">' + escapeXml(cell) + '</w:t>';
                    xml += '</w:r>';
                    xml += '</w:p>';
                    xml += '</w:tc>';
                });
                xml += '</w:tr>';
            });

            xml += '</w:tbl>';
            return xml;
        }

        function getWordDocument(markdown) {
            let xml = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"><w:body>';

            const lines = markdown.split('\n');
            let inTable = false;
            let tableRows = [];

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];

                // Flush table if we were building one
                if (inTable && !line.includes('|')) {
                    xml += buildTable(tableRows);
                    tableRows = [];
                    inTable = false;
                }

                // Title (#)
                if (line.match(/^#\s/)) {
                    const text = line.replace(/^#\s/, '');
                    xml += '<w:p><w:pPr><w:pStyle w:val="Title"/></w:pPr>' + formatTextToXml(text) + '</w:p>';
                }
                // Heading 1 (##)
                else if (line.match(/^##\s/)) {
                    const text = line.replace(/^##\s/, '');
                    xml += '<w:p><w:pPr><w:pStyle w:val="Heading1"/></w:pPr>' + formatTextToXml(text) + '</w:p>';
                }
                // Heading 2 (###)
                else if (line.match(/^###\s/)) {
                    const text = line.replace(/^###\s/, '');
                    xml += '<w:p><w:pPr><w:pStyle w:val="Heading2"/></w:pPr>' + formatTextToXml(text) + '</w:p>';
                }
                // Heading 3 (####)
                else if (line.match(/^####\s/)) {
                    const text = line.replace(/^####\s/, '');
                    xml += '<w:p><w:pPr><w:pStyle w:val="Heading3"/></w:pPr>' + formatTextToXml(text) + '</w:p>';
                }
                // Ordered lists
                else if (line.match(/^\d+\.\s/)) {
                    const text = line.replace(/^\d+\.\s/, '');
                    xml += '<w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:ilvl w:val="0"/><w:numId w:val="1"/></w:numPr></w:pPr>' + formatTextToXml(text) + '</w:p>';
                }
                // Unordered lists
                else if (line.match(/^[\*\-\+]\s/)) {
                    const text = line.replace(/^[\*\-\+]\s/, '');
                    xml += '<w:p><w:pPr><w:pStyle w:val="ListParagraph"/><w:numPr><w:ilvl w:val="0"/><w:numId w:val="2"/></w:numPr></w:pPr>' + formatTextToXml(text) + '</w:p>';
                }
                // Blockquotes
                else if (line.match(/^>\s/)) {
                    const text = line.replace(/^>\s/, '');
                    xml += '<w:p><w:pPr><w:pStyle w:val="Quote"/></w:pPr>' + formatTextToXml(text) + '</w:p>';
                }
                // Code blocks
                else if (line.trim().startsWith('```')) {
                    i++;
                    const code = [];
                    while (i < lines.length && !lines[i].trim().startsWith('```')) {
                        code.push(escapeXml(lines[i]));
                        i++;
                    }
                    xml += '<w:p><w:pPr><w:pStyle w:val="Code"/></w:pPr><w:r><w:rPr><w:rFonts w:ascii="Courier New"/></w:rPr><w:t>' + code.join('\n') + '</w:t></w:r></w:p>';
                }
                // Tables
                else if (line.includes('|')) {
                    inTable = true;
                    const cells = line.split('|').filter(c => c.trim() && !c.match(/^-+$/));
                    if (cells.length > 0) {
                        tableRows.push(cells.map(c => c.trim()));
                    }
                }
                // Horizontal rule
                else if (line.match(/^---+$/)) {
                    xml += '<w:p><w:pPr><w:pBdr><w:bottom w:val="single" w:sz="12" w:space="1" w:color="C0C0C0"/></w:pBdr></w:pPr></w:p>';
                }
                // Normal paragraph
                else if (line.trim()) {
                    xml += '<w:p><w:pPr><w:pStyle w:val="Normal"/></w:pPr>' + formatTextToXml(line) + '</w:p>';
                }
            }

            // Flush remaining table
            if (inTable && tableRows.length > 0) {
                xml += buildTable(tableRows);
            }

            xml += '</w:body></w:document>';
            return xml;
        }
    </script>
</body>
</html>
